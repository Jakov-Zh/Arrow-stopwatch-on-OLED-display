// Ардуино-нано, в качестве секундомера на OLED дисплее c отсчетом времени по встроенному AVR таймеру
 
float s;
float m;
int z;
float f;
int32_t t; 
 
#include <iarduino_OLED.h> // Подключаем библиотеку iarduino_OLED.
#include <avr/interrupt.h> //Подключаем библиотеку обработки прерываний
 
iarduino_OLED myOLED(0x3C);// Объявляем объект myOLED, указывая адрес дисплея на шине I2C: 0x3C или 0x3D.
extern uint8_t SmallFontRus[];// Подключаем шрифт SmallFontRus.
 
void setup() {
    myOLED.begin();// Инициируем работу с дисплеем.
    myOLED.setFont(SmallFontRus); // Указываем шрифт который требуется использовать для вывода текста.
    myOLED.autoUpdate(false);// Запрещаем автоматический вывод данных. Информация на дисплее будет обновляться только после обращения к функции update().
    
    {for (float s=(PI*(-0.5)); s<(PI*1.5-PI/30); s=s+PI/30) // рисуем риски на циферблате
     {myOLED.drawPixel  (64+cos(s)*29, 32+sin(s)*29, 1);}
      
      myOLED.drawCircle (64,32,31,false,1); // рисуем корпус циферблата
      myOLED.drawCircle (64,32,2,true,1); // рисуем центр стрелок
      myOLED.update(); // Обновляем информацию на дисплее.
      myOLED.setCursor(0,6); // отображаем надписи нажмите и старт
      myOLED.print("нажмите");
      myOLED.setCursor(95,6); myOLED.print("старт");
      }
      
      // инициализация Timer1 для организации отсчета секунд и минут
      cli();  // отключить глобальные прерывания
      TCCR1A = 0;   // установить регистры в 0
      TCCR1B = 0;
      OCR1A = 15624; // установка регистра совпадения
      TCCR1B |= (1 << WGM12);  // включить CTC режим 
      TCCR1B |= (1 << CS10); // Установить биты на коэффициент деления 1024
      TCCR1B |= (1 << CS12);
      TIMSK1 |= (1 << OCIE1A);  // включить прерывание по совпадению таймера 
      sei(); // включить глобальные прерывания
      }
 
void loop()
{   
     f=0;// величина на которую увеличивается значение s и m
     s=(PI*(-0.5)); // устанавливаем начальное значение для секунд
     m=(PI*(-0.5)); // устанавливаем начальное значение для минут
     pinMode(13, INPUT); // назначаем 13 порт как вход кнопки  
     
label_min:// цикл минут
      if (m<(PI*1.5-PI/30)) 
      {
label_sec:// цикл секунд
      if (s<(PI*1.5-PI/30)) 
      {
      if (digitalRead (13)==1&&f==0&&s==PI*(-0.5)&&m==PI*(-0.5)) // если: кнопка нажата,секундомер стоит,секунды =0,минуты =0 то запускаем секундомер
      {f=PI/30;
       myOLED.setCursor(95,6);
       myOLED.print("стоп ");
       delay(300);} 
      
      if (digitalRead (13)==1&&f==PI/30) // если: кнопка нажата, идет отсчет секундомера, то останавливаем секундомер
      {f=0;
       myOLED.setCursor(95,6); 
       myOLED.print("сброс ");
       delay(300);}                            
     
      if (digitalRead (13)==1&&f==0&&s!=PI*(-0.5))// если: кнопка нажата,отсчет секундомера не идет,секунды >0, то обнуляем секундомер и очищаем циферблат
      {f=0; 
       s=PI*(-0.5); 
       m=PI*(-0.5); 
       myOLED.drawCircle (64,32,27,true,0);
       myOLED.setCursor(95,6); 
       myOLED.print("старт ");
       delay(300);}  
      
       myOLED.drawLine   (64, 32,  64+cos(s-PI/30)*27, 32+sin(s-PI/30)*27, 0); // стираем сек стрелку
       myOLED.drawLine   (64, 32,  64+cos(m-PI/30)*21, 32+sin(m-PI/30)*21, 0); // стираем мин стрелку
       myOLED.drawLine   (64, 32,  64+cos(s)*27, 32+sin(s)*27, 1);// рисуем сек стрелку
       myOLED.drawLine   (64, 32,  64+cos(m)*21, 32+sin(m)*21, 1);// рисуем мин стрелку
       myOLED.drawCircle (64,32,2,true,1); // рисуем центр стрелок
     
       myOLED.update();// Обновляем информацию на дисплее.
      
     goto label_sec;
     }
     else {s=(PI*(-0.5));goto label_min;}
     }
     else {m=PI*(-0.5);goto label_sec;}}
     
     ISR(TIMER1_COMPA_vect) {s=s+f; m=m+f/60;} // раз в секунду увеличиваем счетчик секунд на 1, минут на 1/60
